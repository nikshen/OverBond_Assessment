# The objective of this code is to tackle the questions asked in the assessment# The below code captures the JSON file into an variable d and reads the content into a variable of type dictionary data_readimport jsond = open ('sample_input.json',)data_read = json.load(d)number_of_records = len(data_read ['data']) # determining the number of records in the input file data_output  = {'data':[]}  # empty dictionary to write the results for i in range (0, number_of_records):        # we first determine if             # 1. The record is a corporate bond or not            # 2. The yeild value of the bond is 'None' or not         if (data_read['data'][i]['id'][0].lower() == 'c' and data_read['data'][i]['yield'] != None ):                tenor = float(data_read['data'][i]['tenor'].replace( years, '')) # we capture the tenor of the corporate bond here        else:            continue                    # defining counters and variables to store results         scale_diff = float(0)        scale = float(1000)        n = 1        ot_amnt = float(0)        yield_value = str()        ref_id = str()                        # determining the government bond benchmark         for n in range (0, number_of_records):            # we first determine if the record is a governement bond             # Assumption: government bond record will always have a 'yield' value, it will not be Null or None            if data_read['data'][n]['id'][0].lower() == 'g':                gov_tenor = float(data_read['data'][n]['tenor'].replace( years, ''))                scale_diff = abs(tenor - gov_tenor) # we compute the difference of the tenor of the corporate bond and the govt bond                # logical check to determine the closes govt bond                if scale_diff < scale:                      scale = scale_diff                     ref_id = data_read['data'][n]['id']                    ot_amnt = float(data_read['data'][n]['amount_outstanding'])                    yield_value = data_read['data'][n]['yield']                # additional check to ensure if the difference is same, we check the outstanding amount                 # Understanding - if the outstanding amount is same, we pick the first record                elif scale_diff == scale:                    if data_read['data'][n]['amount_outstanding'] > ot_amnt:                        scale = scale_diff                         ref_id = data_read['data'][n]['id']                        ot_amnt = float(data_read['data'][n]['amount_outstanding'])                        yield_value = data_read['data'][n]['yield']                    else:                        pass                                    else:                    pass             else:                continue                        # determining the base points        corporate_yield = float(data_read['data'][i]['yield'].replace('%','') )        gov_yield = float(yield_value.replace('%','') )        base_points = round(abs(corporate_yield-gov_yield) * 100)                #preparing the output set         spread_to_benchmark = str(base_points) + ' bps'        corporate_bond_id = data_read['data'][i]['id']        result = {'corporate_bond_id' : corporate_bond_id, 'government_bond_id' : ref_id, 'spread_to_benchmark' : spread_to_benchmark}    data_output ['data']. append(result)
    
    
# writing the output in json file
with open ('sample_output.json', 'w') as outfile:
    json.dump (data_output, outfile)